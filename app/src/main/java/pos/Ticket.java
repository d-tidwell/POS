package pos;
import java.util.HashMap;
import java.util.ArrayList;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * Ticket class takes associates map of seat positions with Items for a table number and ticket owner.
 * Used to create views for kitchen of a table. Has a method to consolidate Items by station for kitchen view.
 */

public class Ticket {

    //SeatPos / Item list
    private final HashMap<String, ArrayList<Item>> ticketMap;

    //an unchangeable time/date object
    private final LocalDateTime ticketTime;

    //an order-number that self generates on entry
    private final Integer ticketNumber;

    //where it goes
    private final int tableNumber;

    //who owns the order?
    private final String ticketOwner;

    //live or dead?
    private String ticketStatus = "OPEN";  // "CLOSED"

    /**
     * Constructor creates a Ticket object. Each ticket is timestamped with current time. TicketNumber is
     * autogenerated by OrderNumerator.
     * @param ticketMap  k:seat position, v:List of Items for that seat position
     * @param tableNumber Table number
     * @param ticketOwner  Server or Ticket author
     */
    public Ticket(HashMap<String, ArrayList<Item>> ticketMap,int tableNumber, String ticketOwner){
        this.ticketMap = ticketMap;
        this.ticketTime = LocalDateTime.now();
        this.ticketNumber = OrderNumerator.numberTicket();
        this.tableNumber = tableNumber;
        this.ticketOwner = ticketOwner;
        
    }

    /**
     * Getter for ticketNumber
     * @return int number of ticket
     */
    public int getTicketNumber(){
        //returns ticket number 
        return this.ticketNumber;
    }

    /**
     * Getter for tableNumber
     * @return int of table
     */
    public int getTableNumber(){
        //returns table number and number indicates
        return this.tableNumber;
    }

    /**
     * Getter for timestamp created at order generation.
     * @return String value of ticket entered time
     */
    public String getTicketTime(){
        //returns formatted datetime obj
        DateTimeFormatter formatOrderEntryTime = DateTimeFormatter.ofPattern("dd-MM-yyyy HH:mm:ss:nn");
        return ticketTime.format(formatOrderEntryTime);
    }

    /**
     * Getter for ticketOwner
     * @return String ticketOwner
     */
    public String getTicketOwner(){
        //returns the server or order-originator
        return this.ticketOwner;
    }

    /**
     * Getter for ticketStatus either OPEN or CLOSED
     * @return String ticketStatus
     */
    public String getTicketStatus(){
       //OPEN or CLOSED
        return this.ticketStatus;
        
    }

    /**
     * Setter for ticketStatus either OPEN or CLOSED
     * @param statusCode
     */
    public void setTicketStatus(boolean statusCode){
        //Sets open or closed for order
        if(!statusCode){
            this.ticketStatus = "CLOSED";
        }
    }

    /**
     * Method to consolidate ticket into a HashMap of a HashMap to represent a kitchen friendly view of
     * {"GRILL": "100001": 3} where station is first, item is second and number of items is accumulated. So in this case
     * there are 3 each items on order of "100001" for the GRILL station.
     * @return  HashMap<String, HashMap<String, Integer>> {"GRILL": "100001": 3}
     */
    public HashMap<String, HashMap<String, Integer>> consolidateTicket(){
        //makes a consolidated order for each station in stations for easier viewing of ticket in stations
        // Station: Item: Count
        // {"GRILL": "100001": 3}
        HashMap<String, HashMap<String, Integer>> consolidated = new  HashMap<String, HashMap<String, Integer>>();

        //for seatPos in map
        for(String seatPos: this.ticketMap.keySet()){

            //for item in array of items
            for(int i = 0; i < this.ticketMap.get(seatPos).size(); i++){

                //get the station of the item
                String station = this.ticketMap.get(seatPos).get(i).getStation();

                //get the item object
                Item item = this.ticketMap.get(seatPos).get(i);
                

                //if the station does not exist initialize it to zero
                if(!consolidated.containsKey(station)){
                    //create an item hash map of items and values for redundancy of items
                    HashMap<String, Integer> itemCount = new HashMap<String, Integer>();
                    itemCount.put(item.getID(), 1);
                    consolidated.put(station, itemCount);
                    
                }
                else{
                    //otherwise get the station the item and add one to the count
                    HashMap<String, Integer> stationMap = consolidated.get(station);
                    stationMap.put(item.getID(), stationMap.get(item.getID()) + 1);
                    consolidated.put(station,stationMap);
                    
                }

            }
        }

        return consolidated;


    }

}
